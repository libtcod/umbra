================================================================================
Umbra TODO List
================================================================================
TO DISCUSS
================================================================================
Mouse support
- shall we add a new localMouseBinding to the module or merge everything in
the update function as I suggested ?
bool update( float elapsed, TCOD_key_t k, TCOD_mouse_t mouse )
  - add a mouse() interpreter in modules.
  virtual void UmbraModule::mouse(TCOD_moust_t mouse) {}
  I'm against adding it to the update(). If the engine calls it itself, the dev
  won't have to keep track of what neds to be placed in update(). Same goes for
  keyboard.
	Fair enough. What about :
	class Module {
		bool update();
		void keyboard(TCOD_key_t &k);
		void mouse(TCOD_mouse_t mouse);
	}
	I pass the k by reference in case a module want to stop the event
	propagation to other modules (for example by replacing TCOD_key_t.vk with
	TCODK_NONE). Is it ok for you ?

================================================================================
Project structure
- rename 'mod' directory to 'demo' - YES
- main.cpp and main.hpp should be moved to the 'demo' directory, version.hpp
to the umbra directory - YES
- there should be a umbra/umbra.hpp so that we only have to include it to
use umbra
  - you want to place all class implementations in a single cpp file? Maybe at a
  later stage then, when the engine is closer to ready?
    simply move the #include "umbra/XXX" from main.hpp to umbra.hpp
    then have only #include "umbra/umbra.hpp" in main.hpp

================================================================================
Multiple active modules support
Currently, Umbra only update/renders a single module. Instead, loops through
the active modules list.
=> activate all modules in toActivate list
=> update all active modules
   if a module exits, add its fallback to a 'toActivate' list 
   (don't activate it in current frame)
=> then renders all active modules
=> if no more active module, exit game

	seems OK. Need to discuss it via chat.

================================================================================
Module life cycle
- registered module is uninitialized (no resource used except the Module object)
- at first activation, it is initialized (allocate data, load pictures, sounds, 
...), then activated
  - delay on loading a module. I'd initialise most of the data in the
  constructor, and call Module::initialise() only to init dynamic stuff
- at any time it can be paused (renders but doesn't update) and resumed
  - added. press PAUSE in the 2nd module to test.
- when its update function returns false, it's deactivated
  - of course.
Suggestion :
class Module {
	bool initialized; //yeah
	bool active; //the engine needs to know it. Does the module?
	bool paused; //yeah
	void init(); //definitely
	//void activate();
	//void deactivate();
	//void pause();
	//void resume();
	void setActive (bool active);
	void setPause (bool pause);
	void deinitialise (void);
}
class Engine {
	TCODList<Module> modules; // all registered modules
	TCODList<Module> actives;
	void activate(int moduleId);
	void deactivate(int moduleId);
	void pause(int moduleId);
	void resume(int moduleId);
}

What's the difference between Engine::activate and Module::activate? Which one
does what?
My thinking:
Engine::activate -> adds to the active list, possibly calls Module::activate
Module::activate -> sets Module::active flag. Is it at all necessary?
	Yes it's a bit overkill but it's handy to be able to know if a module is 
	active without having to scan the whole active list. 

================================================================================

